<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å·¥ç¨‹æ¡ˆä¾‹3DæŸ¥çœ‹å™¨ï¼ˆè‡ªåŠ¨åŠ è½½ç‰ˆï¼‰</title>
    <!-- ä»…ä¿ç•™å¿…éœ€ä¾èµ–ï¼Œé¿å…å†²çª -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/PointerLockControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/RGBELoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/objects/EquirectangularToCubeGenerator.js"></script>
    <!-- ç½‘é¡µå›¾æ ‡ -->
    <link rel="icon" href="data:image/svg+xml,svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22>text y=%22.9em%22 font-size=%2290%22>3D/text>/svg>">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Arial', sans-serif;
        }
        body {
            background: #000;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        header {
            background: #2c3e50;
            color: white;
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            flex-wrap: wrap;
            gap: 1rem;
        }
        .info-container {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }
        #model-info, #hdr-info {
            background: white;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            font-size: 0.9rem;
            color: #333;
            min-width: 180px;
            text-align: center;
        }
        /* é€Ÿåº¦è°ƒèŠ‚æ§ä»¶æ ·å¼ */
        .speed-control {
            background: white;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            font-size: 0.9rem;
            color: #333;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        #speed-slider {
            width: 120px;
            cursor: pointer;
        }
        /* è¿”å›ä¸»é¡µé¢æŒ‰é’® */
        .back-btn {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: background 0.3s ease;
        }
        .back-btn:hover {
            background: #c0392b;
        }
        #canvas-container {
            flex: 1;
            position: relative;
        }
        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 1.2rem;
            display: block;
        }
        .error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #e74c3c;
            font-size: 1.2rem;
            display: none;
            text-align: center;
            max-width: 80%;
        }
        #control-hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 0.9rem;
            z-index: 100;
            text-align: center;
        }
        /* ç§»åŠ¨ç«¯é€‚é… */
        @media (max-width: 768px) {
            header {
                flex-direction: column;
                gap: 1rem;
                padding: 1rem;
            }
            .info-container {
                width: 100%;
                justify-content: center;
            }
            #control-hint {
                font-size: 0.8rem;
                padding: 8px 15px;
                max-width: 90%;
            }
            .speed-control, .back-btn {
                width: 100%;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>å·¥ç¨‹æ¡ˆä¾‹3DæŸ¥çœ‹å™¨</h1>
        <div class="info-container">
            <div id="model-info">åŠ è½½ä¸­...æ¨¡å‹</div>
            <div id="hdr-info">åŠ è½½ä¸­...ç¯å¢ƒ</div>
            <!-- é€Ÿåº¦è°ƒèŠ‚æ§ä»¶ï¼ˆ1-50ï¼‰ -->
            <div class="speed-control">
                ç§»åŠ¨é€Ÿåº¦: <span id="speed-value">10</span>
                <input type="range" id="speed-slider" min="1" max="50" value="10">
            </div>
            <!-- è¿”å›ä¸»é¡µé¢æŒ‰é’® -->
            <button class="back-btn" onclick="window.location.href='wangye.html'">è¿”å›ä¸»é¡µé¢</button>
        </div>
    </header>
    
    <div id="canvas-container">
        <div class="loading" id="loading">åŠ è½½ä¸­...è¯·ç¨å€™</div>
        <div class="error" id="error">åŠ è½½å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•</div>
        <div id="control-hint">
            ğŸ® æ“ä½œè¯´æ˜ï¼šç‚¹å‡»å±å¹•é”å®šé¼ æ ‡ | WASDï¼šå‰åå·¦å³ | Q/Eï¼šä¸Šä¸‹ç§»åŠ¨ï¼ˆæ‚¬ç©ºï¼‰ | Shiftï¼šåŠ é€Ÿ | ESCï¼šé‡Šæ”¾é¼ æ ‡ | é€Ÿåº¦ï¼š1-50å¯è°ƒ
        </div>
    </div>
    <script>
        // å…¨å±€å˜é‡
        let scene, camera, renderer, controls, model;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let moveUp = false, moveDown = false;
        let isRunning = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let prevTime = performance.now();
        let hdrTexture = null;
        let cubeRenderTarget = null;
        let baseSpeed = 10;
        
        // DOMå…ƒç´ 
        const loadingElem = document.getElementById('loading');
        const errorElem = document.getElementById('error');
        const canvasContainer = document.getElementById('canvas-container');
        const speedSlider = document.getElementById('speed-slider');
        const speedValue = document.getElementById('speed-value');
        const modelInfo = document.getElementById('model-info');
        const hdrInfo = document.getElementById('hdr-info');
        
        // ä»URLè·å–æ¨¡å‹å’ŒHDRè·¯å¾„å‚æ•°
        const urlParams = new URLSearchParams(window.location.search);
        const MODEL_PATH = urlParams.get('model') || 'models/default.glb'; // é»˜è®¤æ¨¡å‹è·¯å¾„
        const HDR_PATH = urlParams.get('hdr') || 'hdrs/default.hdr'; // é»˜è®¤HDRè·¯å¾„
        
        // é¡µé¢åŠ è½½å®Œæˆåˆå§‹åŒ–
        window.onload = function() {
            initScene();
            bindSpeedControl();
            // è‡ªåŠ¨åŠ è½½æ¨¡å‹å’ŒHDRç¯å¢ƒ
            loadHDRFromPath(HDR_PATH);
            loadModelFromPath(MODEL_PATH);
        };
        
        // åˆå§‹åŒ–åœºæ™¯
        function initScene() {
            // 1. åœºæ™¯é…ç½®
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);
            scene.environmentIntensity = 1.0;
            
            // 2. ç›¸æœºé…ç½®
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);
            
            // 3. æ¸²æŸ“å™¨é…ç½®
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                physicallyCorrectLights: true,
                alpha: false
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            renderer.outputEncoding = THREE.sRGBEncoding;
            canvasContainer.appendChild(renderer.domElement);
            
            // 4. ç¬¬ä¸€äººç§°æ§åˆ¶å™¨
            controls = new THREE.PointerLockControls(camera, document.body);
            document.body.addEventListener('click', () => {
                if (!controls.isLocked) {
                    controls.lock();
                }
            });
            document.addEventListener('pointerlockerror', () => {
                console.warn('æŒ‡é’ˆé”å®šæš‚æ—¶ä¸å¯ç”¨ï¼Œç‚¹å‡»å±å¹•é‡è¯•');
            });
            
            // 5. å…‰ç…§ç³»ç»Ÿ
            initLights();
            
            // 6. åˆ›å»ºåœ°é¢
            createGround();
            
            // 7. ç»‘å®šé”®ç›˜äº‹ä»¶
            bindKeyEvents();
            
            // 8. çª—å£é€‚é…
            window.addEventListener('resize', onWindowResize);
            
            // 9. åŠ¨ç”»å¾ªç¯
            animate();
        }
        
        // åˆå§‹åŒ–å…‰æº
        function initLights() {
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const mainLight = new THREE.DirectionalLight(0xffffff, 1.8);
            mainLight.position.set(15, 20, 10);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 4096;
            mainLight.shadow.mapSize.height = 4096;
            mainLight.shadow.bias = -0.001;
            mainLight.shadow.camera.near = 0.5;
            mainLight.shadow.camera.far = 200;
            mainLight.shadow.camera.left = -50;
            mainLight.shadow.camera.right = 50;
            mainLight.shadow.camera.top = 50;
            mainLight.shadow.camera.bottom = -50;
            scene.add(mainLight);
            
            const pointLight1 = new THREE.PointLight(0x88aaff, 0.8, 50);
            pointLight1.position.set(20, 15, 15);
            scene.add(pointLight1);
            
            const pointLight2 = new THREE.PointLight(0xaa88ff, 0.6, 40);
            pointLight2.position.set(-15, 10, -10);
            scene.add(pointLight2);
        }
        
        // åˆ›å»ºåœ°é¢
        function createGround() {
            const groundGeometry = new THREE.PlaneGeometry(200, 200);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x1a1a33,
                roughness: 0.6,
                metalness: 0.2,
                receiveShadow: true,
                envMapIntensity: 0.8
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = 0;
            scene.add(ground);
        }
        
        // ç»‘å®šé”®ç›˜äº‹ä»¶
        function bindKeyEvents() {
            document.addEventListener('keydown', (event) => {
                switch (event.code) {
                    case 'KeyW': moveForward = true; break;
                    case 'KeyA': moveLeft = true; break;
                    case 'KeyS': moveBackward = true; break;
                    case 'KeyD': moveRight = true; break;
                    case 'KeyQ': moveDown = true; break;
                    case 'KeyE': moveUp = true; break;
                    case 'ShiftLeft': isRunning = true; break;
                }
            });
            
            document.addEventListener('keyup', (event) => {
                switch (event.code) {
                    case 'KeyW': moveForward = false; break;
                    case 'KeyA': moveLeft = false; break;
                    case 'KeyS': moveBackward = false; break;
                    case 'KeyD': moveRight = false; break;
                    case 'KeyQ': moveDown = false; break;
                    case 'KeyE': moveUp = false; break;
                    case 'ShiftLeft': isRunning = false; break;
                }
            });
        }
        
        // ç»‘å®šé€Ÿåº¦è°ƒèŠ‚äº‹ä»¶
        function bindSpeedControl() {
            speedValue.textContent = baseSpeed;
            speedSlider.addEventListener('input', (e) => {
                baseSpeed = parseInt(e.target.value);
                speedValue.textContent = baseSpeed;
            });
        }
        
        // ä»æŒ‡å®šè·¯å¾„åŠ è½½HDRç¯å¢ƒ
        function loadHDRFromPath(hdrPath) {
            showLoading(`æ­£åœ¨åŠ è½½ç¯å¢ƒ: ${getFileName(hdrPath)}`);
            hdrInfo.textContent = `åŠ è½½ä¸­: ${getFileName(hdrPath)}`;
            
            const loader = new THREE.RGBELoader();
            loader.load(hdrPath, (texture) => {
                if (hdrTexture) hdrTexture.dispose();
                if (cubeRenderTarget) cubeRenderTarget.dispose();
                
                hdrTexture = texture;
                hdrTexture.mapping = THREE.EquirectangularReflectionMapping;
                hdrTexture.encoding = THREE.sRGBEncoding;
                hdrTexture.generateMipmaps = true;
                hdrTexture.minFilter = THREE.LinearMipmapLinearFilter;
                hdrTexture.magFilter = THREE.LinearFilter;
                
                cubeRenderTarget = new THREE.WebGLCubeRenderTarget(hdrTexture.image.height, {
                    format: THREE.RGBAFormat,
                    generateMipmaps: true,
                    minFilter: THREE.LinearMipmapLinearFilter
                });
                cubeRenderTarget.fromEquirectangularTexture(renderer, hdrTexture);
                
                scene.background = cubeRenderTarget.texture;
                scene.environment = cubeRenderTarget.texture;
                scene.environmentIntensity = 0.8;
                
                scene.traverse((child) => {
                    if (child.material && child.material.isMeshStandardMaterial) {
                        child.material.envMap = cubeRenderTarget.texture;
                        child.material.envMapIntensity = 0.8;
                        child.material.needsUpdate = true;
                    }
                });
                
                hdrInfo.textContent = `ç¯å¢ƒ: ${getFileName(hdrPath)}`;
                checkLoadComplete();
            }, (progress) => {
                const percent = (progress.loaded / progress.total * 100).toFixed(1);
                loadingElem.textContent = `åŠ è½½ç¯å¢ƒ: ${percent}%`;
            }, (error) => {
                console.error('HDRåŠ è½½å¤±è´¥:', error);
                showError('ç¯å¢ƒåŠ è½½å¤±è´¥: ' + (error.message || 'æ–‡ä»¶ä¸å­˜åœ¨'));
                hdrInfo.textContent = 'ç¯å¢ƒåŠ è½½å¤±è´¥';
            });
        }
        
        // ä»æŒ‡å®šè·¯å¾„åŠ è½½GLBæ¨¡å‹
        function loadModelFromPath(modelPath) {
            showLoading(`æ­£åœ¨åŠ è½½æ¨¡å‹: ${getFileName(modelPath)}`);
            modelInfo.textContent = `åŠ è½½ä¸­: ${getFileName(modelPath)}`;
            
            if (model) {
                scene.remove(model);
                model.traverse((obj) => {
                    if (obj.geometry) obj.geometry.dispose();
                    if (obj.material) {
                        Array.isArray(obj.material) 
                            ? obj.material.forEach(mat => mat.dispose()) 
                            : obj.material.dispose();
                    }
                });
                model = null;
            }
            
            const loader = new THREE.GLTFLoader();
            loader.load(modelPath, (gltf) => {
                model = gltf.scene;
                
                const box = new THREE.Box3().setFromObject(model);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = maxDim > 30 ? 30 / maxDim : 1.5;
                
                model.scale.set(scale, scale, scale);
                model.position.sub(center.multiplyScalar(scale));
                model.position.y = 0;
                
                model.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        if (child.material.isMeshStandardMaterial) {
                            if (child.material.metalness > 0.3) {
                                child.material.metalness = Math.min(child.material.metalness + 0.2, 0.95);
                                child.material.roughness = Math.max(child.material.roughness - 0.3, 0.05);
                            } else {
                                child.material.envMapIntensity = 1.8;
                            }
                            if (child.material.emissiveIntensity) {
                                child.material.emissiveIntensity = Math.max(child.material.emissiveIntensity, 1.5);
                            }
                            child.material.needsUpdate = true;
                        } else {
                            const newMat = new THREE.MeshStandardMaterial({
                                map: child.material.map,
                                color: child.material.color,
                                metalness: 0.6,
                                roughness: 0.4,
                                emissiveIntensity: 1.2
                            });
                            child.material.dispose();
                            child.material = newMat;
                        }
                    }
                });
                
                scene.add(model);
                
                const modelCenter = box.getCenter(new THREE.Vector3()).multiplyScalar(scale);
                camera.position.set(modelCenter.x, modelCenter.y + 5, modelCenter.z + Math.max(size.x, size.z) * 1.5);
                camera.lookAt(modelCenter);
                
                modelInfo.textContent = `æ¨¡å‹: ${getFileName(modelPath)} | å°ºå¯¸: ${size.x.toFixed(2)}x${size.y.toFixed(2)}x${size.z.toFixed(2)}`;
                checkLoadComplete();
            }, (progress) => {
                const percent = (progress.loaded / progress.total * 100).toFixed(1);
                loadingElem.textContent = `åŠ è½½æ¨¡å‹: ${percent}%`;
            }, (error) => {
                console.error('æ¨¡å‹åŠ è½½å¤±è´¥:', error);
                showError('æ¨¡å‹åŠ è½½å¤±è´¥: ' + (error.message || 'æ–‡ä»¶ä¸å­˜åœ¨'));
                modelInfo.textContent = 'æ¨¡å‹åŠ è½½å¤±è´¥';
            });
        }
        
        // çª—å£å¤§å°è°ƒæ•´
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);
            
            if (controls.isLocked) {
                const time = performance.now();
                const delta = (time - prevTime) / 1000;
                
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y = 0;
                
                if (moveUp) velocity.y = baseSpeed * 2 * delta;
                if (moveDown) velocity.y = -baseSpeed * 2 * delta;
                
                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();
                
                const currentSpeed = isRunning ? baseSpeed * 1.5 : baseSpeed;
                if (moveForward || moveBackward) velocity.z -= direction.z * currentSpeed * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * currentSpeed * delta;
                
                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                camera.position.y += velocity.y;
                
                prevTime = time;
            }
            
            renderer.render(scene, camera);
        }
        
        // å·¥å…·å‡½æ•°ï¼šè·å–æ–‡ä»¶åï¼ˆä»è·¯å¾„ä¸­æå–ï¼‰
        function getFileName(path) {
            return path.split('/').pop().split('\\').pop();
        }
        
        // å·¥å…·å‡½æ•°ï¼šæ£€æŸ¥æ˜¯å¦åŠ è½½å®Œæˆ
        function checkLoadComplete() {
            if (modelInfo.textContent.includes('æ¨¡å‹:') && hdrInfo.textContent.includes('ç¯å¢ƒ:')) {
                hideLoading();
            }
        }
        
        // çŠ¶æ€æ§åˆ¶å‡½æ•°
        function showLoading(text = 'åŠ è½½ä¸­...è¯·ç¨å€™') {
            loadingElem.textContent = text;
            loadingElem.style.display = 'block';
        }
        
        function hideLoading() {
            loadingElem.style.display = 'none';
        }
        
        function showError(text = 'åŠ è½½å¤±è´¥') {
            hideLoading();
            errorElem.textContent = text;
            errorElem.style.display = 'block';
            setTimeout(() => {
                errorElem.style.display = 'none';
            }, 3000);
        }
    </script>
</body>
</html>